.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::MethodMaker::V1Compat 3"
.TH Class::MethodMaker::V1Compat 3 "2011-02-28" "perl v5.14.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MethodMaker::V1Compat \- V1 compatibility code for C::MM
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This class is for internal implementation only.  It is not a public \s-1API\s0.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class::MethodMaker version 2 strives for backward-compatiblity with version 1
as far as possible.  That is to say, classes built with version 1 should work
with few if any changes.  However, the calling conventions for building new
classes are significantly different: this is necessary to achieve a greater
consistency of arguments.
.PP
Version 2 takes all arguments within a single arrayref:
.PP
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => \*(Aqa\*(Aq ];
.Ve
.PP
If arguments are presented as a list, then Class::MethodMaker assumes that
this is a version 1 call, and acts accordingly.  Version 1 arguments are
passed and internally rephrased to version 2 arguments, and passed off to the
version 2 engine.  Thus, the majority of version 1 calls can be upgraded to
version 2 merely by rephrasing.  However, there are a number of behaviours
that in version 1 that are internally inconsistent.  These behaviours are
mimicked in version 1 mode as far as possible, but are not reproducible in
version 2 (to allow version 2 clients to rely on a more internally consistent
interface).
.SS "Version 2 Implementations"
.IX Subsection "Version 2 Implementations"
The nearest equivalent to each 1 component (slot) available in version 2 is
shown below using the indicated data-structures & options to create a
component called \f(CW\*(C`a\*(C'\fR that mimicks the V1 component behaviour as closely as
possible:
.IP "abstract" 4
.IX Item "abstract"
.Vb 2
\&  use Class::MethodMaker
\&    [ abstract => \*(Aqa\*(Aq ];
.Ve
.IP "boolean" 4
.IX Item "boolean"
Boolean is available as a backwards compatiblity hack, but there is currently
no V2 equivalent.  It is likely that some replacement mechanism will be
introduced in the future, but that it will be incompatible with the version 1
boolean.
.IP "code" 4
.IX Item "code"
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => \*(Aqa\*(Aq ];
.Ve
.Sp
Let's face it, the v1 store-if-it's-a-coderef-else-retrieve semantics are
rather broken.  How do you pass a coderef as argument to one of these?  It is
on the \s-1TODO\s0 list to recognize code as fundamental restricted type (analogous
to \s-1INTEGER\s0), which would add in a \f(CW*_invoke\fR method.
.IP "copy" 4
.IX Item "copy"
.Vb 2
\&  use Class::MethodMaker
\&    [ copy => \*(Aqa\*(Aq ];
.Ve
.Sp
The v2 method is the same as v1.
.IP "counter" 4
.IX Item "counter"
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [{\-type => Class::MethodMaker::Constants::INTEGER}, \*(Aqa\*(Aq] ];
.Ve
.IP "copy" 4
.IX Item "copy"
.PD 0
.IP "deep_copy" 4
.IX Item "deep_copy"
.PD
.Vb 2
\&  use Class::MethodMaker
\&    [ copy => [ \-deep => \*(Aqa\*(Aq ] ];
.Ve
.IP "get_concat" 4
.IX Item "get_concat"
.Vb 9
\&  use Class::MethodMaker
\&    [ scalar => [{ \-store_cb => sub {
\&                                  defined $_[1] ? ( defined $_[3] ?
\&                                                    "$_[3] $_[1]" : $_[1] )
\&                                                : undef;
\&                                }
\&                 },
\&                 \*(Aqa\*(Aq ]
\&    ];
.Ve
.IP "get_set" 4
.IX Item "get_set"
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => \*(Aqa\*(Aq ];
.Ve
.IP "hash" 4
.IX Item "hash"
.Vb 2
\&  use Class::MethodMaker
\&    [ hash => \*(Aqa\*(Aq ];
.Ve
.IP "key_attrib" 4
.IX Item "key_attrib"
Although v1 calls will continue to work, this is not supported in v2.
.IP "key_with_create" 4
.IX Item "key_with_create"
Although v1 calls will continue to work, this is not supported in v2.
.IP "list" 4
.IX Item "list"
.Vb 2
\&  use Class::MethodMaker
\&    [ list => \*(Aqa\*(Aq ];
.Ve
.Sp
Note that the \f(CW\*(C`*\*(C'\fR method now \fIsets\fR the whole array if given arguments.
.IP "method" 4
.IX Item "method"
See \f(CW\*(C`code\*(C'\fR.
.IP "new" 4
.IX Item "new"
.Vb 2
\&  use Class::MethodMaker
\&    [ new => \*(Aqa\*(Aq ];
.Ve
.IP "new_hash_init" 4
.IX Item "new_hash_init"
.Vb 2
\&  use Class::MethodMaker
\&    [ new => [ \-hash => \*(Aqa\*(Aq ] ];
.Ve
.IP "new_hash_with_init" 4
.IX Item "new_hash_with_init"
.Vb 2
\&  use Class::MethodMaker
\&    [ new => [ \-hash => \-init => \*(Aqa\*(Aq ] ];
.Ve
.IP "new_with_args" 4
.IX Item "new_with_args"
Although v1 calls will continue to work, this is not supported in v2, for it
is a trivial application of \f(CW\*(C`new_with_init\*(C'\fR.
.IP "new_with_init" 4
.IX Item "new_with_init"
.Vb 2
\&  use Class::MethodMaker
\&    [ new => [ \-init => \*(Aqa\*(Aq ] ];
.Ve
.IP "object" 4
.IX Item "object"
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [{ \-type    => \*(AqMyClass\*(Aq,
\&                   \-forward => [qw/ method1 method2 /] }, \*(Aqa\*(Aq ]
\&    ];
.Ve
.IP "object_tie_hash" 4
.IX Item "object_tie_hash"
.Vb 7
\&  use Class::MethodMaker
\&    [ hash => [{ \-type      => \*(AqMyClass\*(Aq,
\&                 \-forward   => [qw/ method1 method2 /],
\&                 \-tie_class => \*(AqTie::MyTie\*(Aq,
\&                 \-tie_args  => [qw/ foo bar baz /],
\&               }, \*(Aqa\*(Aq ]
\&    ];
.Ve
.IP "object_tie_list" 4
.IX Item "object_tie_list"
.Vb 7
\&  use Class::MethodMaker
\&    [ array => [{ \-type      => \*(AqMyClass\*(Aq,
\&                  \-forward   => [qw/ method1 method2 /],
\&                  \-tie_class => \*(AqTie::MyTie\*(Aq,
\&                  \-tie_args  => [qw/ foo bar baz /],
\&                }, \*(Aqa\*(Aq ]
\&    ];
.Ve
.IP "set_once" 4
.IX Item "set_once"
.Vb 8
\&  use Class::MethodMaker
\&    [ scalar => [{ \-store_cb => sub {
\&                                  die "Already stored $_[3]"
\&                                    if @_ > 3;
\&                                }
\&                 },
\&                 \*(Aqa\*(Aq ]
\&    ];
.Ve
.IP "set_once_static" 4
.IX Item "set_once_static"
.Vb 9
\&  use Class::MethodMaker
\&    [ scalar => [{ \-store_cb => sub {
\&                                  die "Already stored $_[3]"
\&                                    if @_ > 3;
\&                                },
\&                   \-static   => 1,
\&                 },
\&                 \*(Aqa\*(Aq ]
\&    ];
.Ve
.IP "singleton" 4
.IX Item "singleton"
.Vb 2
\&  use Class::MethodMaker
\&    [ new => [ \-singleton => \-hash => \-init => \*(Aqa\*(Aq ] ];
.Ve
.IP "static_get_set" 4
.IX Item "static_get_set"
.Vb 2
\&  use Class::MethodMaker
\&    [ scalar => [ \-static => \*(Aqa\*(Aq ], ];
.Ve
.IP "static_hash" 4
.IX Item "static_hash"
.Vb 2
\&  use Class::MethodMaker
\&    [ hash => [ \-static => \*(Aqa\*(Aq ], ];
.Ve
.IP "static_list" 4
.IX Item "static_list"
.Vb 2
\&  use Class::MethodMaker
\&    [ list => [ \-static => \*(Aqa\*(Aq ], ];
.Ve
.IP "tie_hash" 4
.IX Item "tie_hash"
.Vb 4
\&  use Class::MethodMaker
\&    [ hash => [ { \-tie_class => \*(AqMyTie\*(Aq,
\&                  \-tie_args  => [qw/ foo bar baz /],
\&                } => \*(Aqa\*(Aq ], ];
.Ve
.IP "tie_list" 4
.IX Item "tie_list"
.Vb 4
\&  use Class::MethodMaker
\&    [ array => [ { \-tie_class => \*(AqMyTie\*(Aq,
\&                   \-tie_args  => [qw/ foo bar baz /],
\&                 } => \*(Aqa\*(Aq ], ];
.Ve
.IP "tie_scalar" 4
.IX Item "tie_scalar"
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [ { \-tie_class => \*(AqMyTie\*(Aq,
\&                    \-tie_args  => [qw/ foo bar baz /],
\&                  } => \*(Aqa\*(Aq ], ];
.Ve
.SS "Caveats & Expected Breakages"
.IX Subsection "Caveats & Expected Breakages"
The following version 1 component (slot) types are not currently supported in
version 2:
.IP "grouped_fields" 4
.IX Item "grouped_fields"
.PD 0
.IP "hash_of_lists" 4
.IX Item "hash_of_lists"
.IP "listed_attrib" 4
.IX Item "listed_attrib"
.IP "struct" 4
.IX Item "struct"
.PD
.SH "EXAMPLES"
.IX Header "EXAMPLES"

.SH "BUGS"
.IX Header "BUGS"

.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Email the development mailing list \f(CW\*(C`class\-mmaker\-devel@lists.sourceforge.net\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martyn J. Pearce
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003, 2004 Martyn J. Pearce.  This program is free software; you
can redistribute it and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"

